# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/01_actions.ipynb.

# %% auto 0
__all__ = ['send_slack_message', 'run_sql', 'register', 'list_available', 'get_info', 'run']

# %% ../nbs/API/01_actions.ipynb 2
from . import util
import functools
import inspect
from typing import Dict, List, Callable, Optional, Any, Union

# %% ../nbs/API/01_actions.ipynb 6
def send_slack_message(data): 
    """
    Use the returned data to send slack messages. This could be used for creating alerts for data issues, reporting on metrics, etc.
    """
    pass

def run_sql(data): 
    pass

# %% ../nbs/API/01_actions.ipynb 8
util.ACTION_REGISTRY: Dict[str, Callable] = {}

def register(name: str, description: Optional[str] = None, overwrite: bool = False) -> Callable:
    """
    Register your function as an action in the global registry.
    
    **Args**: 
        \n • `name`: Descriptive name for your action
        \n • `description`: Optional description of what the action does

    **Raises**:
       \n • `ValueError`: If an action with the same name already exists
    """
    def decorator(fn: Callable) -> Callable:
        if name in util.ACTION_REGISTRY and util.ACTION_REGISTRY[name] != fn and not overwrite:
            util.logger.warning(f"Action '{name}' already exists. Keeping the existing one.")
            return fn
        if name in util.ACTION_REGISTRY and overwrite:
            util.logger.warning(f"Overwriting existing action '{name}' with new one.")
            # Remove the old action
            del util.ACTION_REGISTRY[name]
            
        # Add metadata to the function
        fn._action_name = name
        fn._action_description = description
        
        # Add to registry
        util.ACTION_REGISTRY[name] = fn
        
        # Preserve function metadata like docstrings
        @functools.wraps(fn)
        def wrapper(*args, **kwargs):
            return fn(*args, **kwargs)
        
        return wrapper
    util.logger.info(f"Registered action: {name}")
    return decorator

# %% ../nbs/API/01_actions.ipynb 9
def list_available():
    """List all registered actions with their descriptions."""
    print("Available actions:")
    for name, fn in util.ACTION_REGISTRY.items():
        description = getattr(fn, "_action_description", "No description available")
        print(f"  - {name}: {description}")
    return util.ACTION_REGISTRY

def get_info(name: str) -> Dict[str, Any]:
    """Get detailed information about a specific action."""
    if name not in util.ACTION_REGISTRY:
        raise ValueError(f"No action named '{name}' is registered.")
    
    fn = util.ACTION_REGISTRY[name]
    info = {
        "name": name,
        "description": getattr(fn, "_action_description", "No description available"),
        "docstring": fn.__doc__ or "No documentation",
        "signature": str(inspect.signature(fn))
    }
    return info

# %% ../nbs/API/01_actions.ipynb 10
def run(action_name: str, data: List[Dict[str, Any]]) -> Any:
    """
    Run a registered action with the provided data.
    
    **Args:** 
        \n • `action_name`: Name of the registered action
        \n • `data`: Data to pass to the action
        
    **Returns:**
        Result of the action
    """
    if action_name not in util.ACTION_REGISTRY:
        raise ValueError(f"No action named '{action_name}' is registered")
    
    action = util.ACTION_REGISTRY[action_name]
    try:
        result = action(data)
        util.logger.info(f"Successfully executed action '{action_name}'")
        return result
    except Exception as e:
        util.logger.error(f"Failed to execute action '{action_name}': {str(e)}")
        raise
